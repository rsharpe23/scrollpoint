{"version":3,"sources":["jquery.scrollpoint.js"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_possibleConstructorReturn","self","call","_assertThisInitialized","_getPrototypeOf","o","Object","setPrototypeOf","getPrototypeOf","__proto__","ReferenceError","_inherits","subClass","superClass","TypeError","create","value","writable","configurable","_setPrototypeOf","p","_classCallCheck","instance","Constructor","_defineProperties","target","props","i","length","descriptor","enumerable","defineProperty","key","_createClass","protoProps","staticProps","$","ScrollPointListener","sPoint","options","this","_eventAccess","events","data","_this","forEach","event","trigger","success","_tryAccessEvent","$element","isEntry","newEventAccess","height","offset","parseInt","ScrollPoint","listeners","window","on","_execute","bind","_this2","DOMRect","getBoundingClientRect","wHeight","innerHeight","scrollDelta","_DOMRect","top","listener","index","calcOffset","triggerAll","once","setTimeout","splice","push","FullPageScrollPoint","_getPrototypeOf2","_this3","_len","arguments","args","Array","_key","apply","concat","DATA_KEY","fn","scrollpoint","each","element","addListener"],"mappings":"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","file":"jquery.scrollpoint.min.js","sourcesContent":["\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n(function ($) {\n  'use strict';\n\n  var ScrollPointListener =\n  /*#__PURE__*/\n  function () {\n    function ScrollPointListener(sPoint, options) {\n      _classCallCheck(this, ScrollPointListener);\n\n      this.sPoint = sPoint;\n      this.options = options;\n      this._eventAccess = 1;\n    }\n\n    _createClass(ScrollPointListener, [{\n      key: \"triggerAll\",\n      value: function triggerAll(events, data) {\n        var _this = this;\n\n        events.forEach(function (event) {\n          return _this.trigger(event, data);\n        });\n      }\n    }, {\n      key: \"trigger\",\n      value: function trigger(event, data) {\n        var success = this._tryAccessEvent(event);\n\n        if (success) {\n          this.options[event] && this.options[event].call(this.sPoint.$element[0], data);\n        }\n\n        return success;\n      }\n    }, {\n      key: \"_tryAccessEvent\",\n      value: function _tryAccessEvent(event) {\n        if (event == 'stay') {\n          return true;\n        }\n\n        if (event == 'enter' || event == 'exit') {\n          var isEntry = event == 'enter';\n          var newEventAccess = isEntry ? this._eventAccess : ~this._eventAccess;\n          newEventAccess &= 1;\n\n          if (newEventAccess) {\n            isEntry ? this._eventAccess <<= 1 : this._eventAccess >>>= 1;\n          }\n\n          return !!newEventAccess;\n        }\n\n        return false;\n      }\n    }, {\n      key: \"calcOffset\",\n      value: function calcOffset(height) {\n        var offset = this.options.offset || 0;\n\n        if (typeof offset == 'string') {\n          offset = parseInt(offset);\n        }\n\n        return height * offset * 0.01;\n      }\n    }]);\n\n    return ScrollPointListener;\n  }();\n\n  var ScrollPoint =\n  /*#__PURE__*/\n  function () {\n    function ScrollPoint($element) {\n      _classCallCheck(this, ScrollPoint);\n\n      this.$element = $element;\n      this.listeners = [];\n      $(window).on('scroll resize', this._execute.bind(this));\n    }\n\n    _createClass(ScrollPoint, [{\n      key: \"refresh\",\n      value: function refresh() {\n        this._execute();\n      } // _execute() {\n      //   const DOMRect = this.$element[0].getBoundingClientRect();\n      //   if (this._DOMRect) {\n      //     const wHeight = window.innerHeight;\n      //     const data = { scrollDelta: this._DOMRect.top - DOMRect.top };\n      //     this.listeners.forEach((listener, index) => {\n      //       const offset = listener.calcOffset(wHeight);\n      //       // Устанавлить offset стоит только для верхней стороны, \n      //       // иначе на маленьких элементах будет неправильный расчет соотношений.\n      //       if ((DOMRect.top + offset) < wHeight && (DOMRect.top + DOMRect.height) > 0) {\n      //         listener.triggerAll(['enter', 'stay'], data);\n      //       } else {\n      //         if (listener.trigger('exit', data) && listener.options.once) {\n      //           // HACK: Т.к. метод вызывается в процессе цикла,\n      //           // необходимо чтобы текущий listener удалялся после его завершения.\n      //           // setTimeout(..., 0) вызывает переданную функцию только\n      //           // после завершения выполнения текущего кода.\n      //           setTimeout(() => this.listeners.splice(index, 1));\n      //         }\n      //       }\n      //     });\n      //   }\n      //   this._DOMRect = DOMRect;\n      // }\n\n    }, {\n      key: \"_execute\",\n      value: function _execute() {\n        var _this2 = this;\n\n        var DOMRect = this.$element[0].getBoundingClientRect();\n        var wHeight = window.innerHeight;\n        var data = {\n          scrollDelta: this._DOMRect ? this._DOMRect.top - DOMRect.top : 0\n        };\n        this.listeners.forEach(function (listener, index) {\n          var offset = listener.calcOffset(wHeight); // Устанавлить offset стоит только для верхней стороны, \n          // иначе на маленьких элементах будет неправильный расчет соотношений.\n\n          if (DOMRect.top + offset < wHeight && DOMRect.top + DOMRect.height > 0) {\n            listener.triggerAll(['enter', 'stay'], data);\n          } else {\n            if (listener.trigger('exit', data) && listener.options.once) {\n              // HACK: Т.к. метод вызывается в процессе цикла,\n              // необходимо чтобы текущий listener удалялся после его завершения.\n              // setTimeout(..., 0) вызывает переданную функцию только\n              // после завершения выполнения текущего кода.\n              setTimeout(function () {\n                return _this2.listeners.splice(index, 1);\n              });\n            }\n          }\n        });\n        this._DOMRect = DOMRect;\n      }\n    }, {\n      key: \"addListener\",\n      value: function addListener(options) {\n        this.listeners.push(new ScrollPointListener(this, options));\n      }\n    }]);\n\n    return ScrollPoint;\n  }();\n\n  var FullPageScrollPoint =\n  /*#__PURE__*/\n  function (_ScrollPoint) {\n    _inherits(FullPageScrollPoint, _ScrollPoint);\n\n    function FullPageScrollPoint() {\n      var _getPrototypeOf2;\n\n      var _this3;\n\n      _classCallCheck(this, FullPageScrollPoint);\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      _this3 = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(FullPageScrollPoint)).call.apply(_getPrototypeOf2, [this].concat(args))); // super() должен вызываться перед первым this\n      // Подписываться на this.$element неверно, т.к.\n      // scrollPoint может быть не только экран но элемент внутри экрана.\n\n      $('.fp-container:first').on('fullpagescroll', _this3._execute.bind(_assertThisInitialized(_this3)));\n      return _this3;\n    }\n\n    return FullPageScrollPoint;\n  }(ScrollPoint);\n\n  var DATA_KEY = 'rsh.scrollpoint'; // Здесь используется функциональное выражение вместо\n  // стрелочной функций, т.к. та не имеет своего this\n\n  $.fn.scrollpoint = function (options) {\n    return this.each(function (index, element) {\n      var $element = $(element);\n      var instance = $element.data(DATA_KEY);\n\n      if (!instance) {\n        $element.data(DATA_KEY, instance = new FullPageScrollPoint($element));\n      }\n\n      instance.addListener(options);\n    });\n  };\n})($);\n//# sourceMappingURL=jquery.scrollpoint.js.map\n"]}